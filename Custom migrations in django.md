### Заполнение данных в Django
Есть два хороших способа заполнить базу значениями - добавить команду в manage.py или написать собственную миграцию. Давайте посмотрим как это работает.
Для примера я создал простое прилоежние с несколькими моделями. Рабочий код можно посмотреть здесь: https://gitlab.com/itfox-web/medium/django-commands

https://cdn-images-1.medium.com/max/800/1*YbI-Pjskp5IG2vX_QalT5w.jpeg

Модели проекта:
```python
from django.db import models

class CatBreeds(models.Model):
    breed_name = models.CharField(
        max_length=255, unique=True, blank=False, verbose_name='Порода кота')

    def __str__(self):
        return f'Порода {self.breed_name}'

    class Meta:
        verbose_name = 'Порода кота'
        verbose_name_plural = 'Попроды котов'


class Cats(models.Model):
    name = models.CharField(max_length=255, unique=True,
                            blank=False, verbose_name='Имя кота')
    cat_breed = models.ForeignKey(CatBreeds, null=True, blank=True, on_delete=models.DO_NOTHING)

    def __str__(self):
        return f'Кот {self.name}'

    class Meta:
        verbose_name = 'Кот'
        verbose_name_plural = 'Котов'
```

#### Django commands
Добавить команду для проекта несложно, нужно добавить класс Command наследуемый от ```BaseCommand``` и определить в нем метод ```handle()```. Файл с классом надо положить в директорию ```managment/commands```, название файла будет названием команды. Вот так будет выглядеть структура проекта:

```bash
├── django_commands <-- корневая директория сайта django
│   ├── some_app <-- директория приложения
│   │   ├── management
│   │   │   └── commands
│   │   │       ├── create_cat_breeds.py <-- первая команда
│   │   │       ├── create_cats.py <-- вторая команда
│   │   ├── admin.py
│   │   ├── apps.py
│   │   └── models.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
```

А вот так можно посмотреть список команд и вызвать нужную:

```bash
$ ./manage.py --help

Type 'manage.py help <subcommand>' for help on a specific subcommand.

Available subcommands:

[django]
    check
    compilemessages
    createcachetable
...

[some_app]
    create_cat_breeds 
    create_cats 

$ ./manage.py create_cats
  
All default cats updated. Have a nice day!
```

Аргументы будут переданы в параметры args и kwargs функции. Исходный код файла команды, ```create_cats.py```: 

```python
from django.core.management.base import BaseCommand
from annoying.functions import get_object_or_None

from django_commands.some_app.models import Cats

CAT_NAMES = ['Василий', 'Пётр', 'Лаваш', 'Мурлок', 'Сырок', 'Хвост']

class Command(BaseCommand):
    help = 'Add default cats' # Описание команды

    def handle(self, *args, **kwargs):
        # Проходим по всем именам и создаём для каждого имени кота
        for cat_name in CAT_NAMES: 
            cat_object = get_object_or_None(
                Cats, name=cat_name)

            if cat_object is None:
                cat_object = Cats()

            cat_object.name = cat_name

            cat_object.save()

        print('All default cats updated. Have a nice day!')
```

В команды можно вынести рутиные действия по обслуживанию приложения и заполнения данными.

#### Заполнение данных через миграции
Ну а что делать, если в модели появилось поле (в нашем случае bread_type) уже после того, как таблица модели появилась в базе, а поле нужно заполнить не каким-то одним значением, а для каждого объекта модели оно должно быть другим? Можно написать команду, которая заполнит это поле и выполнять эту команду сразу после миграции, но выполнять команду каждый раз после миграции не удобно - можно про это банально забыть.

Лучше написать свою миграцию, которая будет заполнять эти данные. Для начала сделаем пустую миграцию:

```bash
./manage.py makemigrations --name fill_cat_breeds some_app --empty
```

Вот что для нас сгенерит django:
```python
# Generated by Django 3.2.7 on 2021-09-08 11:08
from django.db import migrations
class Migration(migrations.Migration):
dependencies = [('some_app', '0003_alter_cats_options'),]
operations = []
```

Теперь нам надо добавить свой код для заполнения поля:
```python
def fill_cats_breed(apps, schema_editor):
  pass
def delete_cats_breed(apps, schema_editor):
  pass
operations = [
migrations.RunPython(fill_cats_breed,reverse_code=delete_cats_breed,]
```

```fill_cats_breed``` - будет вызвана, когда миграцию применится, а ```delete_cats_breed``` - в том случае, если миграцию надо будет отменить.

Теперь сами эти функции, ```0002_fill_cat_breeds.py```:
```python
from django.db import migrations, transaction
import random


class Migration(migrations.Migration):

    dependencies = []

    def fill_cats_breed(apps, schema_editor):
        db_alias = schema_editor.connection.alias

        cat_breeds_list = list(apps.get_model(
        "some_app", "CatBreeds").objects.all())
        cats = apps.get_model("some_app", "Cats")

        with transaction.atomic():
            print('\nFilling cat breeds:')
            for cat in cats.objects.using(db_alias).filter(cat_breed__isnull=True).all():
                print(cat)
                cat.cat_breed = random.choice(cat_breeds_list)
                cat.save()


    def delete_cats_breed(apps, schema_editor):
        db_alias = schema_editor.connection.alias

        cats = apps.get_model("some_app", "Cats")

        with transaction.atomic():
            print('\nCleaning cat breeds:')
            for cat in cats.objects.using(db_alias).filter(cat_breed__isnull=False).all():
                print(cat)
                cat.cat_breed = None
                cat.save()
                
  operations = [
        migrations.RunPython(fill_cats_breed, delete_cats_breed)
    ]
```

Теперь разберём что там происходит в методе заполнения:
```db_alias = schema_editor.connection.alias```
Получаем подключение к базе данных
```cat_breeds_list = list(apps.get_model("some_app", "CatBreeds").objects.using(db_alias).all())```
Получаем все объекты модели CatBreeds и помещаем их в список
```cats = apps.get_model("some_app", "Cats")```
Получаем модель Cats
```with transaction.atomic():```
Запускаем транзакцию, если что-то сломается, то ц нас не останется заполненых наполовину объектов
```for cat in cats.objects.using(db_alias).filter(cat_breed__isnull=True).all():```
Выбираем всех котов, у которых не заполнена порода
```
cat.cat_breed = random.choice(cat_breeds_list)
cat.save()
```
Выбираем случайную породу и записываем ее в объект кота и сохраняем его
В методе ```delete_cats_breed``` происходит примерно тоже самое, но породы мы очищаем. 

Вот собственно и всё: мы добавили команды для заполнения котов и их пород и миграцию, которая будет заполнять породы котов на случайные.

Надеюсь, что это было полезно :)
